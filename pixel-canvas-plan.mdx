# Pixel Canvas — Implementation Plan

## Overview
Collaborative real-time pixel art canvas. 30-40 simultaneous users paint on a shared 25×30 grid. Ship fast, throwaway app, no auth.

## Architecture Decisions

### Real-time strategy: Broadcast-first, DB as cold storage
- **Supabase Broadcast** is the sole real-time transport during active use
- DB stores a snapshot for initial load and post-session persistence
- No continuous DB writes during the session — eliminates JSONB merge race conditions
- One periodic snapshot save (every 30s) to guard against tab closes

### Rendering: Canvas element, not DOM grid
- 750 DOM nodes + frequent re-renders = poor mobile perf with 40 concurrent painters
- A single `<canvas>` element with direct pixel drawing is faster and simpler
- Click/tap → calculate cell from coordinates → paint locally + broadcast

### Broadcast batching
- Outgoing cell changes are batched over 80ms before sending
- Incoming batches are applied in one pass to the canvas
- Reduces message volume from hundreds/sec to tens/sec

---

## Project Setup

Create a new Vite + React + TypeScript project with Tailwind CSS.

```bash
npm create vite@latest pixel-canvas -- --template react-ts
cd pixel-canvas
npm install @supabase/supabase-js
npm install -D tailwindcss @tailwindcss/vite
git init
```

Create `.env.local`:
```
VITE_SUPABASE_URL=your_url
VITE_SUPABASE_ANON_KEY=your_anon_key
```

Tailwind setup: use the Vite plugin approach (`@tailwindcss/vite`) with a `@import "tailwindcss"` in `src/index.css`.

---

## Supabase Setup

Run this migration via Supabase dashboard or MCP:

```sql
-- UP
create table pixel_grid (
  id text primary key default 'main',
  state jsonb not null default '{}',
  updated_at timestamptz default now()
);

insert into pixel_grid (id, state) values ('main', '{}');

-- RLS disabled intentionally — public throwaway app
alter table pixel_grid enable row level security;
create policy "public_all" on pixel_grid for all using (true) with check (true);

-- DOWN
drop policy "public_all" on pixel_grid;
drop table pixel_grid;
```

> **Note:** We enable RLS with a permissive policy rather than disabling it entirely. This keeps the Supabase client happy without requiring the service key.

---

## Phase 1 — Core Canvas + Real-time

### File: `src/lib/supabase.ts`
Supabase client singleton using `import.meta.env` vars.

### File: `src/lib/constants.ts`
```ts
export const GRID_ROWS = 30
export const GRID_COLS = 25
export const CELL_SIZE_DESKTOP = 20  // px
export const CELL_SIZE_MOBILE = 14   // px
export const DEFAULT_COLOR = '#f5f0e8'  // parchment off-white
export const COLORS = [
  '#e63946', // red
  '#f77f00', // orange
  '#fcbf49', // yellow
  '#2a9d8f', // teal-green
  '#457b9d', // blue
  '#7b2d8b', // purple
] as const
export const BROADCAST_CHANNEL = 'pixel-canvas'
export const BATCH_INTERVAL_MS = 80       // outgoing broadcast batch window
export const SNAPSHOT_INTERVAL_MS = 30000 // DB snapshot frequency
```

### File: `src/hooks/usePixelGrid.ts`
Core state hook. Responsibilities:

1. **State:** `grid` as a `Map<string, string>` (key = `"row-col"`, value = hex color). Use a `useRef` for the mutable grid to avoid re-renders — the canvas reads from it directly.

2. **On mount:**
   - Fetch `pixel_grid` row where `id = 'main'`
   - Populate grid ref from the `state` JSONB
   - Draw full grid to canvas
   - Subscribe to Supabase Broadcast channel `'pixel-canvas'`

3. **`paintCell(row, col, color)`:**
   - Update grid ref immediately
   - Draw cell to canvas immediately (optimistic)
   - Add `{row, col, color}` to outgoing batch queue

4. **Outgoing batch flush (every `BATCH_INTERVAL_MS`):**
   - If queue is non-empty, broadcast entire queue as one message: `{ type: 'broadcast', event: 'paint', payload: { cells: [{row, col, color}, ...] } }`
   - Clear queue

5. **On broadcast receive (`'paint'` event):**
   - Iterate `payload.cells`, update grid ref, draw each cell to canvas

6. **Snapshot save (every `SNAPSHOT_INTERVAL_MS`):**
   - Convert grid ref to plain object
   - Upsert to `pixel_grid`: `update pixel_grid set state = $1, updated_at = now() where id = 'main'`
   - This is a full overwrite, which is fine — only one snapshot runs at a time and broadcast is the real-time source of truth

7. **Cleanup on unmount:** unsubscribe channel, clear intervals, save final snapshot.

**Return:** `{ gridRef, paintCell, isConnected, isLoading }`

### File: `src/components/PixelCanvas.tsx`
Single `<canvas>` element. Responsibilities:

- Ref to canvas element
- On mount: set canvas width/height based on grid dimensions × cell size
- Expose a `drawCell(row, col, color)` method and a `drawFullGrid(grid)` method
- Handle click/touch events:
  - `onMouseDown` / `onTouchStart` → calculate `(row, col)` from event coordinates relative to canvas
  - Call `paintCell(row, col, selectedColor)`
  - On `onTouchStart`: call `e.preventDefault()` to suppress iOS scroll/zoom
- **Touch-drag painting:** Track `isPointerDown` state. On `onMouseMove` / `onTouchMove` while down, continuously paint cells the pointer passes through. This lets users "draw" by dragging, which feels much better.
- Use `React.useCallback` for event handlers

**Cell size logic:** Use `window.innerWidth` to determine mobile vs desktop cell size on mount. Recalculate on resize.

### File: `src/components/ColorPicker.tsx`
- Row of 6 circular color swatches (32px diameter)
- Selected color has a 3px white ring + box shadow
- Fixed position: bottom of screen on mobile, top on desktop
- Simple flex row, centered, with slight backdrop blur for readability
- `onClick` sets `selectedColor` in parent

### File: `src/App.tsx`
- Dark background: `#1a1a2e`
- Holds `selectedColor` state (default: first color)
- Renders `ColorPicker` + `PixelCanvas`
- Centers canvas in viewport
- Passes `selectedColor` down and `paintCell` from hook

---

## Phase 2 — Polish + Deploy

### 2a. Connection indicator
- Small dot (8px), absolute positioned top-right
- Green (`#2a9d8f`) when channel status is `SUBSCRIBED`, grey (`#666`) otherwise
- Subtle opacity transition

### 2b. Loading state
- While `isLoading` is true, show a centered pulsing dot or small spinner over the dark background
- Once loaded, fade in the canvas

### 2c. Touch event hardening
- Ensure `touch-action: none` CSS on the canvas element to fully disable browser touch gestures
- Test: painting on iOS Safari should not trigger scroll, zoom, or bounce

### 2d. Simple participant counter (nice-to-have)
- On channel subscribe, use Broadcast `presence` to track connected users
- Show "X people connected" as small text near the connection dot
- If this adds complexity, skip it — not critical

### 2e. Deploy to Vercel
- `npm run build` to verify clean build
- Deploy via Vercel CLI or MCP
- Project name: `pixel-canvas`
- Set env vars: `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY`
- Confirm deployment URL works

### 2f. Push to GitHub
- Ensure `.env.local` is in `.gitignore`
- Push all code to `main` branch

---

## Risk Register

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Broadcast message loss under load | Medium | Low | Grid state is in DB; refresh recovers. Batch reduces volume. |
| Canvas blurry on Retina displays | High | Low | Set canvas width/height to `cols * cellSize * devicePixelRatio`, scale context. |
| iOS Safari touch issues | Medium | Medium | `touch-action: none` CSS + `preventDefault` on touchstart. Test on real device. |
| Supabase Broadcast rate limits | Low | High | Batching at 80ms keeps us well under limits. 40 users × ~12 msgs/sec = ~480 msgs/sec total, within Broadcast capacity. |
| Tab close loses unpersisted state | Medium | Low | 30s snapshot interval. Add `beforeunload` handler to flush final snapshot. |

---

## Status Report Format

After completing each phase, return:
- ✅/❌ for each sub-task
- List of files created/modified
- Supabase table confirmed created (yes/no)
- Vercel deployment URL (Phase 2 only)
- Any deviations from the plan and why
- Any issues encountered or things to watch out for
